---
layout:     post
title:      记一次面试
subtitle:   爱回收面试总结
date:       2018-10-14
author:     Yosef
# header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
    - front-end
    - interview
    - 爱回收
---

# 题目

## css

- 一个高度为100px的div 和另一个弟兄div ，占满他们父元素的高度，如何实现？
    ```html
    <div class="ab">  
        <div class="a">div元素a</div>
        <div class="b"> div元素b</div>
    </div>
    <style>
        /* 父容器高300px*/
    .ab{
            height:300px;
            position:relative;
            width: 100px
    }
    /* 假设已知a容器高度66px*/
        .a{
        height:66px;
        width:100px;
        }

    /*在b容器中注意不要设置height属性,top和bottom为0px,同时position为absolute时,b容器就会自动将剩余的填满 */
    .b{
        width:100px;
        position:absolute;
        top:66px;
        bottom:0px;
    }
    </style>
    ```

- div水平纵向居中？

    方案1
    ```css
    div {
        position: relative;/* 相对定位或绝对定位均可 */
        width:500px;
        height:300px;
        top: 50%;
        left: 50%;
        margin: -150px 0 0 -250px;/* 外边距为自身宽高的一半 */
        background-color: pink;/* 方便看效果 */
    }
    ```
    方案2
    ```css
    div {
        position: absolute;/* 相对定位或绝对定位均可 */
        width:500px;
        height:300px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: pink;/* 方便看效果 */
    }
    ```

    方案3
    ```css
    .container {
        display: flex;
        align-items: center; /* 垂直居中 */
        justify-content: center;/* 水平居中 */
    }
    .container div {
        width: 100px;
        height: 100px;
        background-color: pink;/* 方便看效果 */
    }  
    ```

- 行内元素的padding是否有效？

        左右（padding-left和padding-right有效），上下（padding-top和padding-bottom)无效。

### js

- 不定参数个数，求和？

    [参考](https://github.com/mqyqingfeng/Blog/issues/12)

    方法1

    ```js
    function sum(){
        var sum = 0;
        //arguments代表一个可变参数，是一个数组，数组里面元素的个数是可变的
        var data = arguments;
        for (var i in data) {
            sum = sum + data[i]
        }
        console.log(sum)
    }
    ```

    方法2

    ```js
    function sum(...arr){
    var sum = 0;
    sum = arr.reduce((prev,next)=>prev+next,0);
    console.log(sum)
    }
    ```

    方法3

    ```js
    function sum(){
    var sum = 0;
    var arr = Array.prototype.slice.call(arguments);
    sum = arr.reduce(function(prev,next){
        return prev+next;
    },0)
    console.log(sum);
    }
    ```

- 数组去重？

    方法1
    ```js
    function uniqueArray(arr) {
        return [...new Set(arr)]
    }
    ```

    方法2
    ```js
    function uniqueArray(arr) {
        const n = [];//临时数组
        for(var i = 0;i < array.length; i++){
            if(n.indexOf(array[i]) === -1) n.push(array[i]);
        }
        return n;
    }
    ```

    方法3
    ```js
    function uniqueArray(arr) {
        const obj = {};
        for(let i = 0;i < array.length; i++){
            if(!obj[i]) obj[i] = i;
        }
        return Object.values(obj);
    }
    ```

- bind函数，实现？

    方法1
    ```js
    Function.prototype.bind2 = function (context) {
        var self = this;
        return function () {
            return self.apply(context);
        }
    }
    ```

    方法2
    ```js
    Function.prototype.bind2 = function (context) {
        var self = this;
        // 获取bind2函数从第二个参数到最后一个参数
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            // 这个时候的arguments是指bind返回的函数传入的参数
            var bindArgs = Array.prototype.slice.call(arguments);
            return self.apply(context, args.concat(bindArgs));
        }
    }
    ```

    方法3
    ```js
    Function.prototype.bind2 = function (context) {
        var self = this;
        var args = Array.prototype.slice.call(arguments, 1);

        var fBound = function () {
            var bindArgs = Array.prototype.slice.call(arguments);
            // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
            // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
            // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
            return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
        }
        // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
        fBound.prototype = this.prototype;
        return fBound;
    }
    ```

    方法4
    ```js
    //方法3中直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：
    Function.prototype.bind2 = function (context) {
        var self = this;
        var args = Array.prototype.slice.call(arguments, 1);
        var fNOP = function () {};
        var fBound = function () {
            var bindArgs = Array.prototype.slice.call(arguments);
            return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
        }
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    }
    ```

- 找到数组第1个不重复的元素的下标（位置）？

    ```js
    function firstUniqueChar(str){
        var str = str || "",
        i = 0,
        k = "",
        _char = "",
        charMap = {},
        result = {name: "",index: str.length};
        for(i=0;i<str.length;i++){
            _char = str.charAt(i);
            if(charMap[_char] != undefined){
                charMap[_char] = -1;
            }else{
                charMap[_char] = i;
            }
        }
        for(k in charMap){
            if(charMap[k]<0){
                continue;
            }
            if(result.index>charMap[k]){
                result.index = charMap[k];
                result.name = k;
            }
        }
        return result.name;
    }
    let str = "vdctdtbvc";
    console.log(firstUniqueChar(str))
    ```

### 网络

- http和https的区别？

    HTTP 缺省工作在TCP协议80端口，用户访问网站http:// 打头的都是标准HTTP服务，HTTP所封装的信息是明文的，通过抓包工具可以分析其信息内容，如果这些信息包含有你的银行卡帐号、密码，你肯定无法接受这种服务，那有没有可以加密这些敏感信息的服务呢？那就是HTTPS！

    HTTPS缺省工作在TCP协议443端口，它的工作流程一般如以下方式：

    1） 完成TCP三次同步握手
    2） 客户端验证服务器数字证书，通过，进入步骤3
    3） DH算法协商对称加密算法的密钥、hash算法的密钥
    4） SSL安全加密隧道协商完成
    5） 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改

    如果HTTPS是网银服务，以上SSL安全隧道成功建立才会要求用户输入账户信息，账户信息是在安全隧道里传输，所以不会泄密

- 高并发的情况，前端需要注意那些事项？

    [转载](https://blog.csdn.net/xlgen157387/article/details/53230138)

1. 应用程序和静态资源文件进行分离

    所谓的静态资源就是我们网站中用到的Html、Css、Js、Image、Video、Gif等静态资源。应用程序和静态资源文件进行分离也是常见的前后端分离的解决方案，应用服务只提供相应的数据服务，静态资源部署在指定的服务器上（Nginx服务器或者是CDN服务器上），前端界面通过Angular JS或者Node JS提供的路由技术访问应用服务器的具体服务获取相应的数据在前端游览器上进行渲染。这样可以在很大程度上减轻后端服务器的压力。

2. 页面缓存

    页面缓存是将应用生成的很少发生数据变化的页面缓存起来，这样就不需要每次都重新生成页面了，从而节省大量CPU资源，如果将缓存的页面放到内存中速度就更快。

    可以使用Nginx提供的缓存功能，或者可以使用专门的页面缓存服务器Squid。

3. 集群与分布式

4. 反向代理

    [参考文章](http://blog.csdn.net/xlgen157387/article/details/49781487)

5. CDN

    CDN服务器其实是一种集群页面缓存服务器，其目的就是尽早的返回用户所需要的数据，一方面加速用户访问速度，另一方面也减轻后端服务器的负载压力。

    CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

    CDN通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。

    也就是说CDN服务器是部署在网络运行商的机房，提供的离用户最近的一层数据访问服务，用户在请求网站服务的时候，可以从距离用户最近的网络提供商机房获取数据。电信的用户会分配电信的节点，联通的会分配联通的节点。

    CDN分配请求的方式是特殊的，不是普通的负载均衡服务器来分配的那种，而是用专门的CDN域名解析服务器在解析与名的时候就分配好的。

    CDN 结构图
    ![alt=CDN_structrue](/img/CDN_structrue.jpg)

- 状态码304的含义？

    [参考文章](https://blog.csdn.net/lanzhihui_10086/article/details/41311933)

    **304 的标准解释是：Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。**

    如果客户端在请求一个文件的时候，发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。

    因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。

    当这些缓存有效的时候，通过 HttpWatch 查看一个请求会得到这样的结果：
    第一次访问 200
    鼠标点击二次访问 (Cache)
    按F5刷新 304
    按Ctrl+F5强制刷新 200
    如果是这样的就说明缓存真正有效了。以上就是我对 HTTP 304 的一个理解。